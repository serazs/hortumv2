-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")

local LocalPlayer = Players.LocalPlayer

-- Karakter bekle
local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- ========== GUI (Basit Aç/Kapa) ==========
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "HortumGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local button = Instance.new("TextButton")
button.Size = UDim2.new(0, 150, 0, 50)
button.Position = UDim2.new(0, 10, 0, 10)
button.Text = "Hortum Açık"
button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
button.TextColor3 = Color3.new(1,1,1)
button.Font = Enum.Font.GothamBold
button.TextSize = 20
button.Parent = screenGui

local modeButton = Instance.new("TextButton")
modeButton.Size = UDim2.new(0, 150, 0, 50)
modeButton.Position = UDim2.new(0, 10, 0, 70)
modeButton.Text = "Mod: Tornado"
modeButton.BackgroundColor3 = Color3.fromRGB(100, 100, 255)
modeButton.TextColor3 = Color3.new(1,1,1)
modeButton.Font = Enum.Font.GothamBold
modeButton.TextSize = 18
modeButton.Parent = screenGui

-- ========== Değişkenler ==========
local enabled = true
local mode = "Tornado"
local radius = 60  -- Biraz büyüttüm
local height = 80
local rotationSpeed = 1  -- Daha yavaş dönüş ki şekil belli olsun
local attractionStrength = 5000

-- Tüm part'leri topla
local parts = {}
local partData = {}  -- part -> {angle, speed}
local nextAngle = 0  -- Yeni part'lara sırayla açı vermek için
local angleStep = math.rad(10)  -- Her part arasındaki açı farkı (derece cinsinden 10 derece)

-- Part ekleme fonksiyonu
local function addPart(part)
    if part:IsA("BasePart") and part:IsDescendantOf(Workspace) then
        if part:IsDescendantOf(LocalPlayer.Character) then return end
        for _, p in ipairs(parts) do
            if p == part then return end
        end
        table.insert(parts, part)
        -- Yeni part'a sıradaki açıyı ata
        partData[part] = {
            angle = nextAngle,
            speed = 0.8 + math.random() * 0.4  -- Hızları yakın olsun ki düzen bozulmasın
        }
        nextAngle = (nextAngle + angleStep) % (2 * math.pi)
    end
end

-- Mevcut tüm part'leri tara
for _, part in ipairs(Workspace:GetDescendants()) do
    addPart(part)
end

Workspace.DescendantAdded:Connect(addPart)

-- ========== Kalp fonksiyonu (daha belirgin) ==========
local function getHeartPoint(t, center, scale)
    -- scale'i biraz büyütelim ki kalp daha iri olsun
    local s = scale / 10  -- Eskiden /12 idi, şimdi /10 yaptım
    local x = 16 * math.sin(t)^3 * s
    local z = (13 * math.cos(t) - 5 * math.cos(2*t) - 2 * math.cos(3*t) - math.cos(4*t)) * s
    return Vector3.new(center.X + x, center.Y, center.Z + z)
end

-- ========== Ana döngü ==========
RunService.Heartbeat:Connect(function()
    if not enabled then return end
    
    if not LocalPlayer.Character or not humanoidRootPart then return end
    
    local center = humanoidRootPart.Position
    local time = tick()
    
    for part, data in pairs(partData) do
        if part and part.Parent then
            -- Part'ı hareket ettirilebilir yap
            pcall(function() part.Anchored = false end)
            pcall(function() part.CanCollide = false end)
            pcall(function() part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0) end)
            
            local targetPos
            
            if mode == "Tornado" then
                local pos = part.Position
                local angle = math.atan2(pos.Z - center.Z, pos.X - center.X)
                local newAngle = angle + math.rad(rotationSpeed * 10)
                targetPos = Vector3.new(
                    center.X + math.cos(newAngle) * radius,
                    center.Y + height * math.sin(time * 2 + angle),
                    center.Z + math.sin(newAngle) * radius
                )
            else -- Heart
                -- Açıyı güncelle (dönme efekti) - yavaş dönüyor
                data.angle = data.angle + math.rad(rotationSpeed * data.speed)
                if data.angle > 2 * math.pi then data.angle = data.angle - 2 * math.pi end
                
                local heartPoint = getHeartPoint(data.angle, center, radius)
                -- Yükseklik dalgalanması (azalttım ki şekil daha net)
                local yOffset = height * 0.2 * math.sin(time * 1.5 + data.angle)
                targetPos = Vector3.new(heartPoint.X, center.Y + yOffset, heartPoint.Z)
            end
            
            local direction = (targetPos - part.Position).unit
            part.Velocity = direction * attractionStrength
        else
            partData[part] = nil
        end
    end
end)

-- ========== Buton işlevleri ==========
button.MouseButton1Click:Connect(function()
    enabled = not enabled
    if enabled then
        button.Text = "Hortum Açık"
        button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    else
        button.Text = "Hortum Kapalı"
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    end
end)

modeButton.MouseButton1Click:Connect(function()
    if mode == "Tornado" then
        mode = "Heart"
        modeButton.Text = "Mod: Kalp"
    else
        mode = "Tornado"
        modeButton.Text = "Mod: Tornado"
    end
end)

StarterGui:SetCore("SendNotification", {
    Title = "Süper Hortum",
    Text = "Aktif! Kalp şekli iyileştirildi.",
    Duration = 3
})
